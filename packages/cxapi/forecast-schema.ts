/**
 * This file was auto-generated by openapi-typescript.
 * Do not make direct changes to the file.
 */

export interface paths {
  "/status": {
    /** Handle healthcheck. */
    get: operations["get_status_status"];
  };
  "/tenants/{tenant_id}/wfm/competencies/{competency_id}/historical": {
    /** Retrieve a set of historical data. */
    get: operations["get_tenants_tenant_id_wfm_competencies_competency_id_historical"];
    /** Add historical data, overlapping data points are overwritten. */
    post: operations["post_tenants_tenant_id_wfm_competencies_competency_id_historical"];
    /** Delete a range of historical data. */
    delete: operations["delete_tenants_tenant_id_wfm_competencies_competency_id_historical"];
  };
  "/tenants/{tenant_id}/wfm/forecastscenarios": {
    /** Retrieve all scenarios. */
    get: operations["get_all_tenants_tenant_id_wfm_forecastscenarios"];
    /** Add a new forecast scenario. */
    post: operations["post_tenants_tenant_id_wfm_forecastscenarios"];
  };
  "/tenants/{tenant_id}/wfm/forecastscenarios/{forecast_scenario_id}": {
    /** Retrieve a single scenario. */
    get: operations["get_tenants_tenant_id_wfm_forecastscenarios_forecast_scenario_id"];
    /** Mark a single scenario as deleted. */
    delete: operations["delete_tenants_tenant_id_wfm_forecastscenarios_forecast_scenario_id"];
    /** Update a single scenario. */
    patch: operations["patch_tenants_tenant_id_wfm_forecastscenarios_forecast_scenario_id"];
  };
  "/tenants/{tenant_id}/wfm/forecastscenarios/{forecast_scenario_id}/params": {
    /** Retrieve a scenario's forecast params. */
    get: operations["get_params_tenants_tenant_id_wfm_forecastscenarios_forecast_scenario_id_params"];
    /** Save forecast params to a scenario. */
    put: operations["put_params_tenants_tenant_id_wfm_forecastscenarios_forecast_scenario_id_params"];
    /** Delete a scenario's forecast params. */
    delete: operations["delete_params_tenants_tenant_id_wfm_forecastscenarios_forecast_scenario_id_params"];
  };
  "/tenants/{tenant_id}/wfm/forecastscenarios/{forecast_scenario_id}/forecast": {
    /**
     * Initialize forecast creation.
     *
     * Kicks off a a new forecast using the params that have been assigned to the
     * scenario. The forecasting process is initiated and the corresponding data
     * series are generated as empty entities. The request will return before
     * finishing the forecasts and a client will have to monitor the data series
     * to find out when the forecasting process has finished. The request will
     * fail if there are ongoing forecast jobs running when the request is made.
     * All existing data series for the scenario will be deleted. Any content
     * in the request body will be disregarded.
     *
     * If any of the included triplets are missing historical data, no forecast
     * will be initiated. This can either be due to missing historical data for
     * the daily forecast or missing historical data to forecast the intraday
     * distribution. Both of these data ranges are specified in the forecast
     * params. A list of running series and a list of series for which no
     * forecast was started will be returned in the response.
     */
    post: operations["init_forecast_tenants_tenant_id_wfm_forecastscenarios_forecast_scenario_id_forecast"];
  };
  "/tenants/{tenant_id}/wfm/forecastscenarios/{scenario_id}/series": {
    /** Retrieve a forecast's data series. */
    get: operations["get_all_tenants_tenant_id_wfm_forecastscenarios_scenario_id_series"];
    /** Add a new forecast data series. */
    post: operations["post_tenants_tenant_id_wfm_forecastscenarios_scenario_id_series"];
  };
  "/tenants/{tenant_id}/wfm/forecastscenarios/{scenario_id}/series/{series_id}": {
    /** Retrieve a single forecast data series. */
    get: operations["get_tenants_tenant_id_wfm_forecastscenarios_scenario_id_series_series_id"];
    /** Delete a single data series. */
    delete: operations["delete_tenants_tenant_id_wfm_forecastscenarios_scenario_id_series_series_id"];
    /** Update a single data series. */
    patch: operations["patch_tenants_tenant_id_wfm_forecastscenarios_scenario_id_series_series_id"];
  };
  "/tenants/{tenant_id}/wfm/forecasttimelines": {
    /** Retrieve all timelines. */
    get: operations["get_all_tenants_tenant_id_wfm_forecasttimelines"];
    /** Create a new timeline. */
    post: operations["post_timelines_tenants_tenant_id_wfm_forecasttimelines"];
  };
  "/tenants/{tenant_id}/wfm/forecasttimelines/{forecast_timeline_id}": {
    /** Retrieve single forecast timeline. */
    get: operations["get_timeline_tenants_tenant_id_wfm_forecasttimelines_forecast_timeline_id"];
    /** Delete single forecast timeline. */
    delete: operations["delete_timeline_tenants_tenant_id_wfm_forecasttimelines_forecast_timeline_id"];
    /** Update a single timeline. */
    patch: operations["patch_timeline_tenants_tenant_id_wfm_forecasttimelines_forecast_timeline_id"];
  };
  "/tenants/{tenant_id}/wfm/forecasttimelines/{forecast_timeline_id}/scenarios": {
    /** Retrieve all scenarios for a timeline. */
    get: operations["get_timeline_scenarios_tenants_tenant_id_wfm_forecasttimelines_forecast_timeline_id_scenarios"];
    /**
     * Add a forecast scenario to a timeline.
     *
     * When a forecast scenario is added to a timeline it means that the
     * forecast series of that scenario will be used as part of the timeline
     * and therefore be the source for scheduling based on the timeline. Adding
     * a scenario to a timeline will fail if the timeline already contains a
     * time series for the same combination of competency, channel and direction
     * for the same time period. If the forecast for a scenario is re-run after
     * it has been added to the scenario the data used in the timeline will be
     * updated.
     */
    post: operations["post_timeline_scenario_tenants_tenant_id_wfm_forecasttimelines_forecast_timeline_id_scenarios"];
    /**
     * Delete a single scenario from timeline.
     *
     * Deleting a forecast will simultaneously delete the forecast's data series
     * and adjustments.
     */
    delete: operations["delete_forecast_timeline_scenario_tenants_tenant_id_wfm_forecasttimelines_forecast_timeline_id_scenarios"];
  };
  "/tenants/{tenant_id}/wfm/forecasttimeline/{forecast_timeline_id}/adjustments": {
    /** Retrieve all adjustments. */
    get: operations["get_all_tenants_tenant_id_wfm_forecasttimeline_forecast_timeline_id_adjustments"];
    /**
     * Add new adjustment.
     *
     * Adjustments are required to have a start date time,
     * that matches the chosen interval length. This check
     * is performed in the timezone of the tenant.
     *
     * For example can hour adjustments start on whole hours,
     * while day adjustments should be placed at 0:00.
     *
     * Only quarter hour, hour and day adjustments are supported.
     */
    post: operations["post_tenants_tenant_id_wfm_forecasttimeline_forecast_timeline_id_adjustments"];
  };
  "/tenants/{tenant_id}/wfm/forecasttimeline/{forecast_timeline_id}/adjustments/{adjustment_id}": {
    /** Retrieve a single adjustment. */
    get: operations["get_tenants_tenant_id_wfm_forecasttimeline_forecast_timeline_id_adjustments_adjustment_id"];
    /** Delete a single adjustment. */
    delete: operations["delete_tenants_tenant_id_wfm_forecasttimeline_forecast_timeline_id_adjustments_adjustment_id"];
    /**
     * Update an adjustment.
     *
     * Only quarter hour, hour and day adjustments are supported.
     */
    patch: operations["patch_tenants_tenant_id_wfm_forecasttimeline_forecast_timeline_id_adjustments_adjustment_id"];
  };
  "/tenants/{tenant_id}/wfm/forecasttimelines/{timeline_id}/series/query": {
    /**
     * Retrieve the data series for a timeline.
     *
     * Based on the input parameters this endpoint will return the data series
     * for a timeline. If adjustments are stacked (i.e. more than one adjustment
     * is applied to an interval), any percentage-based adjustment is applied
     * before absolute adjustments.
     *
     * The start and end date in the query is in the tenant timezone, i.e.,
     * timestamps will be relative to the tenants timezone. Timestamps represent
     * the start of the interval.
     *
     * For staffing estimates the sla threshold is taken from the sla assigned to
     * the competency if available, if that is unavailable it is then taken from
     * the assigned default sla for the tenant, in case niether has a sla
     * defined then a fallback default of 20 seconds is used.
     */
    post: operations["timeline_series_queries_tenants_tenant_id_wfm_forecasttimelines_timeline_id_series_query"];
  };
  "/changelog.md": {
    get: operations["_get_changelog_changelog.md"];
  };
}

export interface components {
  schemas: {
    /** The forecast adjustment type. */
    AdjustmentType: "percentage" | "absolute";
    /** Model for holding generic algorithm options. */
    AlgorithmOption: {
      option: string;
      value: string;
    };
    /** Interaction types supported by CxEngage. */
    ChannelType: "voice" | "messaging" | "sms" | "email" | "work-item";
    /** Model for date interval. */
    DatePairDTO: {
      startDate: string;
      endDate: string;
    };
    /** Represent day curve series. */
    DayCurveDTO: {
      weekDay: number;
      curve: number[];
    };
    /** Represent day values series. */
    DayValueDTO: {
      valueType: components["schemas"]["ForecastValueType"];
      values: number[];
    };
    /** The direction of a single interaction or group of interactions. */
    DirectionType: "inbound" | "outbound";
    /** Represent dto model for output responses. */
    ForecastAdjustmentDTO: {
      competency: string;
      channel: components["schemas"]["ChannelType"];
      direction: components["schemas"]["DirectionType"];
      startDateTime: string;
      intervalLength: components["schemas"]["IntervalType"];
      numberOfIntervals: number;
      type: components["schemas"]["AdjustmentType"];
      metric: components["schemas"]["MetricType"];
      value: number;
      description?: string;
      id: string;
      endDateTime: string;
    };
    /** Represent dto model for updates. */
    ForecastAdjustmentPatchDTO: {
      competency?: string;
      channel?: components["schemas"]["ChannelType"];
      direction?: components["schemas"]["DirectionType"];
      startDateTime?: string;
      intervalLength?: components["schemas"]["IntervalType"];
      numberOfIntervals?: number;
      type?: components["schemas"]["AdjustmentType"];
      value?: number;
      description?: string;
    };
    /** The forecast algorithm that should be used. */
    ForecastAlgorithmType: "average" | "prophet";
    /**
     * Response to an initiated forecast.
     *
     * Parameters
     * ----------
     * series:
     *     All series that have been created and forecasted.
     *
     * missing_historical_data:
     *     For these triplets no forecast have been initiated since
     *     no historical data was found during the period in the scenario
     *     params.
     */
    ForecastResponseDTO: {
      series?: components["schemas"]["ForecastTripletDTO"][];
      missingHistoricalData?: components["schemas"]["ForecastTripletDTO"][];
    };
    /** Model for forecast scenarios. */
    ForecastScenarioDTO: {
      id?: string;
      name: string;
      description: string;
      startDate: string;
      endDate: string;
      scenarioType: components["schemas"]["ForecastScenarioType"];
    };
    /** Model for handling forecast params. */
    ForecastScenarioParamsDTO: {
      dayValueDateRanges: components["schemas"]["DatePairDTO"][];
      dayCurveDateRange: components["schemas"]["DatePairDTO"];
      series: components["schemas"]["ForecastSeriesParam"][];
      algorithm: components["schemas"]["ForecastAlgorithmType"];
      includeDayCurve: boolean;
      metrics: components["schemas"]["MetricType"][];
      algorithmOptions: components["schemas"]["AlgorithmOption"][];
    };
    /** Model for patching forecast scenarios. */
    ForecastScenarioPatchDTO: {
      name?: string;
      description?: string;
      startDate?: string;
      endDate?: string;
      scenarioType?: components["schemas"]["ForecastScenarioType"];
    };
    /** The type of forecast scenario. */
    ForecastScenarioType: "temporary" | "permanent";
    /** Represent dto model for output responses. */
    ForecastSeriesDTO: {
      status: components["schemas"]["JobStatus"];
      competency: string;
      channel: components["schemas"]["ChannelType"];
      direction: components["schemas"]["DirectionType"];
      metric: components["schemas"]["MetricType"];
      startDate: string;
      dayCurves: components["schemas"]["DayCurveDTO"][];
      dayValues: components["schemas"]["DayValueDTO"][];
      id: string;
    };
    /** Model for triplet defining forecast data inclusion. */
    ForecastSeriesParam: {
      competency: string;
      channel: components["schemas"]["ChannelType"];
      direction: components["schemas"]["DirectionType"];
    };
    /** Represent dto model for the input update requests. */
    ForecastSeriesPatchDTO: {
      status?: components["schemas"]["JobStatus"];
      competency?: string;
      channel?: components["schemas"]["ChannelType"];
      direction?: components["schemas"]["DirectionType"];
      metric?: components["schemas"]["MetricType"];
      startDate?: string;
      dayCurves?: components["schemas"]["DayCurveDTO"][];
      dayValues?: components["schemas"]["DayValueDTO"][];
    };
    /** Represent dto model for output responses. */
    ForecastTimelineDTO: {
      name: string;
      description?: string;
      id: string;
    };
    /** Represent dto model for patch requests. */
    ForecastTimelinePatchDTO: {
      name?: string;
      description?: string;
    };
    /** Represent dto model for forecast timeline scenarios. */
    ForecastTimelineScenarioDTO: {
      forecastScenarioId: string;
      startDate: string;
      endDate: string;
    };
    /** A list of forecasted (and possibly) adjusted data for a timeline. */
    ForecastTimelineSeriesDTO: {
      competency: string;
      channel: components["schemas"]["ChannelType"];
      direction: components["schemas"]["DirectionType"];
      forecast?: components["schemas"]["ForecastTimelineSeriesDataSeriesDTO"][];
      adjusted?: components["schemas"]["ForecastTimelineSeriesDataSeriesDTO"][];
      staffing?: components["schemas"]["ForecastTimelineSeriesStaffingSeriesDto"][];
    };
    /**
     * The actual data series part of a timeline series.
     *
     * Parameters
     * ----------
     * nco:
     *     Number of Calls Offered, here used also for non-call
     *     interactions. A more suitable name could be
     *     "number of interactions offered".
     * aht:
     *     Average Handling Time, expressed in seconds.
     */
    ForecastTimelineSeriesDataSeriesDTO: {
      timestamp: string;
      nco?: number;
      aht?: number;
      abandons?: number;
    };
    /** Query input for getting timeline data series. */
    ForecastTimelineSeriesQueryDTO: {
      startDate: string;
      endDate: string;
      interval: components["schemas"]["IntervalType"];
      competencyIds: string[];
      channels: components["schemas"]["ChannelType"][];
      directions: components["schemas"]["DirectionType"][];
      includeAdjusted: boolean;
      includeForecast: boolean;
      includeStaffing: boolean;
    };
    /** A forecasted staffing requirement. */
    ForecastTimelineSeriesStaffingSeriesDto: {
      timestamp: string;
      staffing_estimate?: number;
    };
    /** A forecast triplet that corresponds to one data series. */
    ForecastTripletDTO: {
      seriesId?: string;
      competency: string;
      channel: components["schemas"]["ChannelType"];
      direction: components["schemas"]["DirectionType"];
    };
    /** Type of forecast values. */
    ForecastValueType: "forecast" | "upper" | "lower";
    HTTPValidationError: {
      detail?: components["schemas"]["ValidationError"][];
    };
    /** The historical data that should be stored. */
    HistoricalDataDTO: {
      channel: components["schemas"]["ChannelType"];
      direction: components["schemas"]["DirectionType"];
      series: components["schemas"]["TimeSeriesDTO"][];
    };
    /** The aggregation interval. */
    IntervalType: "quarter-hour" | "hour" | "day" | "week" | "month" | "year";
    /** Status for jobs. */
    JobStatus: "pending" | "running" | "success" | "failed";
    /** The type of data in a series. */
    MetricType: "nco" | "aht" | "tot" | "abandons";
    /**
     * Represent dto model for input requests.
     *
     * Currently only the metrics nco and aht are supported.
     */
    NewForecastAdjustmentDTO: {
      competency: string;
      channel: components["schemas"]["ChannelType"];
      direction: components["schemas"]["DirectionType"];
      startDateTime: string;
      intervalLength: components["schemas"]["IntervalType"];
      numberOfIntervals: number;
      type: components["schemas"]["AdjustmentType"];
      metric: components["schemas"]["MetricType"];
      value: number;
      description?: string;
    };
    /** Represent dto model for input requests. */
    NewForecastSeriesDTO: {
      status: components["schemas"]["JobStatus"];
      competency: string;
      channel: components["schemas"]["ChannelType"];
      direction: components["schemas"]["DirectionType"];
      metric: components["schemas"]["MetricType"];
      startDate: string;
      dayCurves: components["schemas"]["DayCurveDTO"][];
      dayValues: components["schemas"]["DayValueDTO"][];
    };
    /** Represent dto model for input requests. */
    NewForecastTimelineDTO: {
      name: string;
      description?: string;
    };
    /** Represent the DTO-model for an Time Series. */
    TimeSeriesDTO: {
      timestamp: string;
      nco: number;
      aht: number;
      abandons: number;
    };
    ValidationError: {
      loc: string[];
      msg: string;
      type: string;
    };
  };
}

export interface operations {
  /** Handle healthcheck. */
  get_status_status: {
    responses: {
      /** Successful Response */
      200: {
        content: {
          "application/json": { [key: string]: any };
        };
      };
    };
  };
  /** Retrieve a set of historical data. */
  get_tenants_tenant_id_wfm_competencies_competency_id_historical: {
    parameters: {
      path: {
        tenant_id: string;
        competency_id: string;
      };
      query: {
        channel: components["schemas"]["ChannelType"];
        direction: components["schemas"]["DirectionType"];
        startDateTime: string;
        endDateTime: string;
      };
      header: {
        "x-cx-auth-tenant"?: string;
        "x-cx-auth-platform"?: string;
      };
    };
    responses: {
      /** Successful Response */
      200: {
        content: {
          "application/json": components["schemas"]["HistoricalDataDTO"];
        };
      };
      /** Validation Error */
      422: {
        content: {
          "application/json": components["schemas"]["HTTPValidationError"];
        };
      };
    };
  };
  /** Add historical data, overlapping data points are overwritten. */
  post_tenants_tenant_id_wfm_competencies_competency_id_historical: {
    parameters: {
      path: {
        tenant_id: string;
        competency_id: string;
      };
      header: {
        "x-cx-auth-tenant"?: string;
        "x-cx-auth-platform"?: string;
      };
    };
    responses: {
      /** Successful Response */
      200: {
        content: {
          "application/json": { [key: string]: any };
        };
      };
      /** Validation Error */
      422: {
        content: {
          "application/json": components["schemas"]["HTTPValidationError"];
        };
      };
    };
    requestBody: {
      content: {
        "application/json": components["schemas"]["HistoricalDataDTO"];
      };
    };
  };
  /** Delete a range of historical data. */
  delete_tenants_tenant_id_wfm_competencies_competency_id_historical: {
    parameters: {
      path: {
        tenant_id: string;
        competency_id: string;
      };
      query: {
        channel: components["schemas"]["ChannelType"];
        direction: components["schemas"]["DirectionType"];
        startDateTime: string;
        endDateTime: string;
      };
      header: {
        "x-cx-auth-tenant"?: string;
        "x-cx-auth-platform"?: string;
      };
    };
    responses: {
      /** Successful Response */
      200: {
        content: {
          "application/json": { [key: string]: any };
        };
      };
      /** Validation Error */
      422: {
        content: {
          "application/json": components["schemas"]["HTTPValidationError"];
        };
      };
    };
  };
  /** Retrieve all scenarios. */
  get_all_tenants_tenant_id_wfm_forecastscenarios: {
    parameters: {
      path: {
        tenant_id: string;
      };
      header: {
        "x-cx-auth-tenant"?: string;
        "x-cx-auth-platform"?: string;
      };
    };
    responses: {
      /** Successful Response */
      200: {
        content: {
          "application/json": components["schemas"]["ForecastScenarioDTO"][];
        };
      };
      /** Validation Error */
      422: {
        content: {
          "application/json": components["schemas"]["HTTPValidationError"];
        };
      };
    };
  };
  /** Add a new forecast scenario. */
  post_tenants_tenant_id_wfm_forecastscenarios: {
    parameters: {
      path: {
        tenant_id: string;
      };
      header: {
        "x-cx-auth-tenant"?: string;
        "x-cx-auth-platform"?: string;
      };
    };
    responses: {
      /** Successful Response */
      200: {
        content: {
          "application/json": components["schemas"]["ForecastScenarioDTO"];
        };
      };
      /** Validation Error */
      422: {
        content: {
          "application/json": components["schemas"]["HTTPValidationError"];
        };
      };
    };
    requestBody: {
      content: {
        "application/json": components["schemas"]["ForecastScenarioDTO"];
      };
    };
  };
  /** Retrieve a single scenario. */
  get_tenants_tenant_id_wfm_forecastscenarios_forecast_scenario_id: {
    parameters: {
      path: {
        tenant_id: string;
        forecast_scenario_id: string;
      };
      header: {
        "x-cx-auth-tenant"?: string;
        "x-cx-auth-platform"?: string;
      };
    };
    responses: {
      /** Successful Response */
      200: {
        content: {
          "application/json": components["schemas"]["ForecastScenarioDTO"];
        };
      };
      /** Validation Error */
      422: {
        content: {
          "application/json": components["schemas"]["HTTPValidationError"];
        };
      };
    };
  };
  /** Mark a single scenario as deleted. */
  delete_tenants_tenant_id_wfm_forecastscenarios_forecast_scenario_id: {
    parameters: {
      path: {
        tenant_id: string;
        forecast_scenario_id: string;
      };
      header: {
        "x-cx-auth-tenant"?: string;
        "x-cx-auth-platform"?: string;
      };
    };
    responses: {
      /** Successful Response */
      200: {
        content: {
          "application/json": { [key: string]: any };
        };
      };
      /** Validation Error */
      422: {
        content: {
          "application/json": components["schemas"]["HTTPValidationError"];
        };
      };
    };
  };
  /** Update a single scenario. */
  patch_tenants_tenant_id_wfm_forecastscenarios_forecast_scenario_id: {
    parameters: {
      path: {
        tenant_id: string;
        forecast_scenario_id: string;
      };
      header: {
        "x-cx-auth-tenant"?: string;
        "x-cx-auth-platform"?: string;
      };
    };
    responses: {
      /** Successful Response */
      200: {
        content: {
          "application/json": components["schemas"]["ForecastScenarioDTO"];
        };
      };
      /** Validation Error */
      422: {
        content: {
          "application/json": components["schemas"]["HTTPValidationError"];
        };
      };
    };
    requestBody: {
      content: {
        "application/json": components["schemas"]["ForecastScenarioPatchDTO"];
      };
    };
  };
  /** Retrieve a scenario's forecast params. */
  get_params_tenants_tenant_id_wfm_forecastscenarios_forecast_scenario_id_params: {
    parameters: {
      path: {
        tenant_id: string;
        forecast_scenario_id: string;
      };
      header: {
        "x-cx-auth-tenant"?: string;
        "x-cx-auth-platform"?: string;
      };
    };
    responses: {
      /** Successful Response */
      200: {
        content: {
          "application/json": components["schemas"]["ForecastScenarioParamsDTO"];
        };
      };
      /** Validation Error */
      422: {
        content: {
          "application/json": components["schemas"]["HTTPValidationError"];
        };
      };
    };
  };
  /** Save forecast params to a scenario. */
  put_params_tenants_tenant_id_wfm_forecastscenarios_forecast_scenario_id_params: {
    parameters: {
      path: {
        tenant_id: string;
        forecast_scenario_id: string;
      };
      header: {
        "x-cx-auth-tenant"?: string;
        "x-cx-auth-platform"?: string;
      };
    };
    responses: {
      /** Successful Response */
      200: {
        content: {
          "application/json": { [key: string]: any };
        };
      };
      /**
       * Failure reasons:
       *
       *                        * The period for intraday historical data includes
       *                          a partial week.
       */
      400: unknown;
      /** Validation Error */
      422: {
        content: {
          "application/json": components["schemas"]["HTTPValidationError"];
        };
      };
    };
    requestBody: {
      content: {
        "application/json": components["schemas"]["ForecastScenarioParamsDTO"];
      };
    };
  };
  /** Delete a scenario's forecast params. */
  delete_params_tenants_tenant_id_wfm_forecastscenarios_forecast_scenario_id_params: {
    parameters: {
      path: {
        tenant_id: string;
        forecast_scenario_id: string;
      };
      header: {
        "x-cx-auth-tenant"?: string;
        "x-cx-auth-platform"?: string;
      };
    };
    responses: {
      /** Successful Response */
      200: {
        content: {
          "application/json": components["schemas"]["ForecastScenarioParamsDTO"];
        };
      };
      /** Validation Error */
      422: {
        content: {
          "application/json": components["schemas"]["HTTPValidationError"];
        };
      };
    };
  };
  /**
   * Initialize forecast creation.
   *
   * Kicks off a a new forecast using the params that have been assigned to the
   * scenario. The forecasting process is initiated and the corresponding data
   * series are generated as empty entities. The request will return before
   * finishing the forecasts and a client will have to monitor the data series
   * to find out when the forecasting process has finished. The request will
   * fail if there are ongoing forecast jobs running when the request is made.
   * All existing data series for the scenario will be deleted. Any content
   * in the request body will be disregarded.
   *
   * If any of the included triplets are missing historical data, no forecast
   * will be initiated. This can either be due to missing historical data for
   * the daily forecast or missing historical data to forecast the intraday
   * distribution. Both of these data ranges are specified in the forecast
   * params. A list of running series and a list of series for which no
   * forecast was started will be returned in the response.
   */
  init_forecast_tenants_tenant_id_wfm_forecastscenarios_forecast_scenario_id_forecast: {
    parameters: {
      path: {
        tenant_id: string;
        forecast_scenario_id: string;
      };
      header: {
        "x-cx-auth-tenant"?: string;
        "x-cx-auth-platform"?: string;
      };
    };
    responses: {
      /** Successful Response */
      200: {
        content: {
          "application/json": components["schemas"]["ForecastResponseDTO"];
        };
      };
      /**
       * Failure. Possible reasons:
       *               * If the scenario has any series that are pending (i.e. there
       *               are ongoing forecast jobs), the request fails.
       */
      400: unknown;
      /** Validation Error */
      422: {
        content: {
          "application/json": components["schemas"]["HTTPValidationError"];
        };
      };
    };
  };
  /** Retrieve a forecast's data series. */
  get_all_tenants_tenant_id_wfm_forecastscenarios_scenario_id_series: {
    parameters: {
      path: {
        tenant_id: string;
        scenario_id: string;
      };
      header: {
        "x-cx-auth-tenant"?: string;
        "x-cx-auth-platform"?: string;
      };
    };
    responses: {
      /** Successful Response */
      200: {
        content: {
          "application/json": components["schemas"]["ForecastSeriesDTO"][];
        };
      };
      /** Validation Error */
      422: {
        content: {
          "application/json": components["schemas"]["HTTPValidationError"];
        };
      };
    };
  };
  /** Add a new forecast data series. */
  post_tenants_tenant_id_wfm_forecastscenarios_scenario_id_series: {
    parameters: {
      path: {
        tenant_id: string;
        scenario_id: string;
      };
      header: {
        "x-cx-auth-tenant"?: string;
        "x-cx-auth-platform"?: string;
      };
    };
    responses: {
      /** Successful Response */
      200: {
        content: {
          "application/json": components["schemas"]["ForecastSeriesDTO"];
        };
      };
      /** Validation Error */
      422: {
        content: {
          "application/json": components["schemas"]["HTTPValidationError"];
        };
      };
    };
    requestBody: {
      content: {
        "application/json": components["schemas"]["NewForecastSeriesDTO"];
      };
    };
  };
  /** Retrieve a single forecast data series. */
  get_tenants_tenant_id_wfm_forecastscenarios_scenario_id_series_series_id: {
    parameters: {
      path: {
        tenant_id: string;
        scenario_id: string;
        series_id: string;
      };
      header: {
        "x-cx-auth-tenant"?: string;
        "x-cx-auth-platform"?: string;
      };
    };
    responses: {
      /** Successful Response */
      200: {
        content: {
          "application/json": components["schemas"]["ForecastSeriesDTO"];
        };
      };
      /** Validation Error */
      422: {
        content: {
          "application/json": components["schemas"]["HTTPValidationError"];
        };
      };
    };
  };
  /** Delete a single data series. */
  delete_tenants_tenant_id_wfm_forecastscenarios_scenario_id_series_series_id: {
    parameters: {
      path: {
        tenant_id: string;
        scenario_id: string;
        series_id: string;
      };
      header: {
        "x-cx-auth-tenant"?: string;
        "x-cx-auth-platform"?: string;
      };
    };
    responses: {
      /** Successful Response */
      200: {
        content: {
          "application/json": { [key: string]: any };
        };
      };
      /** Validation Error */
      422: {
        content: {
          "application/json": components["schemas"]["HTTPValidationError"];
        };
      };
    };
  };
  /** Update a single data series. */
  patch_tenants_tenant_id_wfm_forecastscenarios_scenario_id_series_series_id: {
    parameters: {
      path: {
        tenant_id: string;
        scenario_id: string;
        series_id: string;
      };
      header: {
        "x-cx-auth-tenant"?: string;
        "x-cx-auth-platform"?: string;
      };
    };
    responses: {
      /** Successful Response */
      200: {
        content: {
          "application/json": { [key: string]: any };
        };
      };
      /** Validation Error */
      422: {
        content: {
          "application/json": components["schemas"]["HTTPValidationError"];
        };
      };
    };
    requestBody: {
      content: {
        "application/json": components["schemas"]["ForecastSeriesPatchDTO"];
      };
    };
  };
  /** Retrieve all timelines. */
  get_all_tenants_tenant_id_wfm_forecasttimelines: {
    parameters: {
      path: {
        tenant_id: string;
      };
      header: {
        "x-cx-auth-tenant"?: string;
        "x-cx-auth-platform"?: string;
      };
    };
    responses: {
      /** Successful Response */
      200: {
        content: {
          "application/json": components["schemas"]["ForecastTimelineDTO"][];
        };
      };
      /** Validation Error */
      422: {
        content: {
          "application/json": components["schemas"]["HTTPValidationError"];
        };
      };
    };
  };
  /** Create a new timeline. */
  post_timelines_tenants_tenant_id_wfm_forecasttimelines: {
    parameters: {
      path: {
        tenant_id: string;
      };
      header: {
        "x-cx-auth-tenant"?: string;
        "x-cx-auth-platform"?: string;
      };
    };
    responses: {
      /** Successful Response */
      200: {
        content: {
          "application/json": components["schemas"]["ForecastTimelineDTO"];
        };
      };
      /** Validation Error */
      422: {
        content: {
          "application/json": components["schemas"]["HTTPValidationError"];
        };
      };
    };
    requestBody: {
      content: {
        "application/json": components["schemas"]["NewForecastTimelineDTO"];
      };
    };
  };
  /** Retrieve single forecast timeline. */
  get_timeline_tenants_tenant_id_wfm_forecasttimelines_forecast_timeline_id: {
    parameters: {
      path: {
        tenant_id: string;
        forecast_timeline_id: string;
      };
      header: {
        "x-cx-auth-tenant"?: string;
        "x-cx-auth-platform"?: string;
      };
    };
    responses: {
      /** Successful Response */
      200: {
        content: {
          "application/json": components["schemas"]["ForecastTimelineDTO"];
        };
      };
      /** Validation Error */
      422: {
        content: {
          "application/json": components["schemas"]["HTTPValidationError"];
        };
      };
    };
  };
  /** Delete single forecast timeline. */
  delete_timeline_tenants_tenant_id_wfm_forecasttimelines_forecast_timeline_id: {
    parameters: {
      path: {
        tenant_id: string;
        forecast_timeline_id: string;
      };
      header: {
        "x-cx-auth-tenant"?: string;
        "x-cx-auth-platform"?: string;
      };
    };
    responses: {
      /** Successful Response */
      200: {
        content: {
          "application/json": { [key: string]: any };
        };
      };
      /** Validation Error */
      422: {
        content: {
          "application/json": components["schemas"]["HTTPValidationError"];
        };
      };
    };
  };
  /** Update a single timeline. */
  patch_timeline_tenants_tenant_id_wfm_forecasttimelines_forecast_timeline_id: {
    parameters: {
      path: {
        tenant_id: string;
        forecast_timeline_id: { [key: string]: any };
      };
      header: {
        "x-cx-auth-tenant"?: string;
        "x-cx-auth-platform"?: string;
      };
    };
    responses: {
      /** Successful Response */
      200: {
        content: {
          "application/json": components["schemas"]["ForecastTimelineDTO"];
        };
      };
      /** Validation Error */
      422: {
        content: {
          "application/json": components["schemas"]["HTTPValidationError"];
        };
      };
    };
    requestBody: {
      content: {
        "application/json": components["schemas"]["ForecastTimelinePatchDTO"];
      };
    };
  };
  /** Retrieve all scenarios for a timeline. */
  get_timeline_scenarios_tenants_tenant_id_wfm_forecasttimelines_forecast_timeline_id_scenarios: {
    parameters: {
      path: {
        tenant_id: string;
        forecast_timeline_id: string;
      };
      query: {
        startDate?: string;
        endDate?: string;
      };
      header: {
        "x-cx-auth-tenant"?: string;
        "x-cx-auth-platform"?: string;
      };
    };
    responses: {
      /** Successful Response */
      200: {
        content: {
          "application/json": components["schemas"]["ForecastTimelineScenarioDTO"][];
        };
      };
      /** Validation Error */
      422: {
        content: {
          "application/json": components["schemas"]["HTTPValidationError"];
        };
      };
    };
  };
  /**
   * Add a forecast scenario to a timeline.
   *
   * When a forecast scenario is added to a timeline it means that the
   * forecast series of that scenario will be used as part of the timeline
   * and therefore be the source for scheduling based on the timeline. Adding
   * a scenario to a timeline will fail if the timeline already contains a
   * time series for the same combination of competency, channel and direction
   * for the same time period. If the forecast for a scenario is re-run after
   * it has been added to the scenario the data used in the timeline will be
   * updated.
   */
  post_timeline_scenario_tenants_tenant_id_wfm_forecasttimelines_forecast_timeline_id_scenarios: {
    parameters: {
      path: {
        tenant_id: string;
        forecast_timeline_id: string;
      };
      header: {
        "x-cx-auth-tenant"?: string;
        "x-cx-auth-platform"?: string;
      };
    };
    responses: {
      /** Successful Response */
      200: {
        content: {
          "application/json": { [key: string]: any };
        };
      };
      /** Validation Error */
      422: {
        content: {
          "application/json": components["schemas"]["HTTPValidationError"];
        };
      };
    };
    requestBody: {
      content: {
        "application/json": components["schemas"]["ForecastTimelineScenarioDTO"];
      };
    };
  };
  /**
   * Delete a single scenario from timeline.
   *
   * Deleting a forecast will simultaneously delete the forecast's data series
   * and adjustments.
   */
  delete_forecast_timeline_scenario_tenants_tenant_id_wfm_forecasttimelines_forecast_timeline_id_scenarios: {
    parameters: {
      path: {
        tenant_id: string;
        forecast_timeline_id: string;
      };
      query: {
        forecastScenarioId?: string;
      };
      header: {
        "x-cx-auth-tenant"?: string;
        "x-cx-auth-platform"?: string;
      };
    };
    responses: {
      /** Successful Response */
      200: {
        content: {
          "application/json": { [key: string]: any };
        };
      };
      /** Validation Error */
      422: {
        content: {
          "application/json": components["schemas"]["HTTPValidationError"];
        };
      };
    };
  };
  /** Retrieve all adjustments. */
  get_all_tenants_tenant_id_wfm_forecasttimeline_forecast_timeline_id_adjustments: {
    parameters: {
      path: {
        tenant_id: string;
        forecast_timeline_id: string;
      };
      query: {
        startDateTime: string;
        endDateTime: string;
        competencyId?: string;
        channel?: components["schemas"]["ChannelType"];
        direction?: components["schemas"]["DirectionType"];
        metric?: components["schemas"]["MetricType"];
        interval?: components["schemas"]["IntervalType"];
      };
      header: {
        "x-cx-auth-tenant"?: string;
        "x-cx-auth-platform"?: string;
      };
    };
    responses: {
      /** Successful Response */
      200: {
        content: {
          "application/json": components["schemas"]["ForecastAdjustmentDTO"][];
        };
      };
      /** Validation Error */
      422: {
        content: {
          "application/json": components["schemas"]["HTTPValidationError"];
        };
      };
    };
  };
  /**
   * Add new adjustment.
   *
   * Adjustments are required to have a start date time,
   * that matches the chosen interval length. This check
   * is performed in the timezone of the tenant.
   *
   * For example can hour adjustments start on whole hours,
   * while day adjustments should be placed at 0:00.
   *
   * Only quarter hour, hour and day adjustments are supported.
   */
  post_tenants_tenant_id_wfm_forecasttimeline_forecast_timeline_id_adjustments: {
    parameters: {
      path: {
        tenant_id: string;
        forecast_timeline_id: string;
      };
      header: {
        "x-cx-auth-tenant"?: string;
        "x-cx-auth-platform"?: string;
      };
    };
    responses: {
      /** Successful Response */
      200: {
        content: {
          "application/json": components["schemas"]["ForecastAdjustmentDTO"];
        };
      };
      /**
       * Failure, possible reasons:
       *
       *                      * startDateTime missing timezone specification.
       *                      * unsupported metric: only nco and aht are supported.
       */
      400: unknown;
      /** Validation Error */
      422: {
        content: {
          "application/json": components["schemas"]["HTTPValidationError"];
        };
      };
    };
    requestBody: {
      content: {
        "application/json": components["schemas"]["NewForecastAdjustmentDTO"];
      };
    };
  };
  /** Retrieve a single adjustment. */
  get_tenants_tenant_id_wfm_forecasttimeline_forecast_timeline_id_adjustments_adjustment_id: {
    parameters: {
      path: {
        tenant_id: string;
        forecast_timeline_id: string;
        adjustment_id: string;
      };
      header: {
        "x-cx-auth-tenant"?: string;
        "x-cx-auth-platform"?: string;
      };
    };
    responses: {
      /** Successful Response */
      200: {
        content: {
          "application/json": components["schemas"]["ForecastAdjustmentDTO"];
        };
      };
      /** Validation Error */
      422: {
        content: {
          "application/json": components["schemas"]["HTTPValidationError"];
        };
      };
    };
  };
  /** Delete a single adjustment. */
  delete_tenants_tenant_id_wfm_forecasttimeline_forecast_timeline_id_adjustments_adjustment_id: {
    parameters: {
      path: {
        tenant_id: string;
        forecast_timeline_id: string;
        adjustment_id: string;
      };
      header: {
        "x-cx-auth-tenant"?: string;
        "x-cx-auth-platform"?: string;
      };
    };
    responses: {
      /** Successful Response */
      200: {
        content: {
          "application/json": { [key: string]: any };
        };
      };
      /** Validation Error */
      422: {
        content: {
          "application/json": components["schemas"]["HTTPValidationError"];
        };
      };
    };
  };
  /**
   * Update an adjustment.
   *
   * Only quarter hour, hour and day adjustments are supported.
   */
  patch_tenants_tenant_id_wfm_forecasttimeline_forecast_timeline_id_adjustments_adjustment_id: {
    parameters: {
      path: {
        tenant_id: string;
        forecast_timeline_id: string;
        adjustment_id: string;
      };
      header: {
        "x-cx-auth-tenant"?: string;
        "x-cx-auth-platform"?: string;
      };
    };
    responses: {
      /** Successful Response */
      200: {
        content: {
          "application/json": components["schemas"]["ForecastAdjustmentDTO"];
        };
      };
      /** Validation Error */
      422: {
        content: {
          "application/json": components["schemas"]["HTTPValidationError"];
        };
      };
    };
    requestBody: {
      content: {
        "application/json": components["schemas"]["ForecastAdjustmentPatchDTO"];
      };
    };
  };
  /**
   * Retrieve the data series for a timeline.
   *
   * Based on the input parameters this endpoint will return the data series
   * for a timeline. If adjustments are stacked (i.e. more than one adjustment
   * is applied to an interval), any percentage-based adjustment is applied
   * before absolute adjustments.
   *
   * The start and end date in the query is in the tenant timezone, i.e.,
   * timestamps will be relative to the tenants timezone. Timestamps represent
   * the start of the interval.
   *
   * For staffing estimates the sla threshold is taken from the sla assigned to
   * the competency if available, if that is unavailable it is then taken from
   * the assigned default sla for the tenant, in case niether has a sla
   * defined then a fallback default of 20 seconds is used.
   */
  timeline_series_queries_tenants_tenant_id_wfm_forecasttimelines_timeline_id_series_query: {
    parameters: {
      path: {
        tenant_id: string;
        timeline_id: string;
      };
      header: {
        "x-cx-auth-tenant"?: string;
        "x-cx-auth-platform"?: string;
      };
    };
    responses: {
      /** Successful Response */
      200: {
        content: {
          "application/json": components["schemas"]["ForecastTimelineSeriesDTO"][];
        };
      };
      /** Validation Error */
      422: {
        content: {
          "application/json": components["schemas"]["HTTPValidationError"];
        };
      };
    };
    requestBody: {
      content: {
        "application/json": components["schemas"]["ForecastTimelineSeriesQueryDTO"];
      };
    };
  };
  "_get_changelog_changelog.md": {
    responses: {
      /** Successful Response */
      200: {
        content: {
          "application/json": { [key: string]: any };
        };
      };
    };
  };
}
